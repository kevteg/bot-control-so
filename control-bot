#!/usr/bin/env python
# -*- coding: utf-8 -*-

import telegram
import logging
import sys
import subprocess

class conbot:
    def __init__ (self):
        root = logging.getLogger()
        root.setLevel(logging.INFO)
        ch = logging.StreamHandler(sys.stdout)
        ch.setLevel(logging.DEBUG)
        formatter = \
            logging.Formatter('Hora: %(asctime)s \
                               Objeto: %(name)s \
                               Tipo de dato: %(levelname)s \
                               Mensaje: %(message)s')
        ch.setFormatter(formatter)
        root.addHandler(ch)
        logger = logging.getLogger(__name__)
        self.ruta_actual = "/home/keeeevin/"
        self.comandos = {'start': self.start,
                    'help': self.help,
                    'cd': self.cd,
                    'pwd': self.pwd,
                    'comando': self.comando,
                    'sudo': self.sudo}
        usuario = "@keeeevin"
        self.mensaje_saludo = "Hola. Soy un bot de control para la computadora de " + usuario + ".\nDe tener acceso podras navegar, \
                                descargar datos y ejecutar comandos en su computadora"
        self.mensaje_ayuda  = self.mensaje_saludo + "\n\nMis comandos son: \
                                                help - Ayuda del bot\
                                                cd - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                ls - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                pwd - Mostrar ruta actual\
                                                comando - Ejecutar un comando\
                                                sudo - Guardar contraseña de super usuario\
                                                "
        self.main()

    '''
    brief: Método inicial que crea el handler de comandos
    '''
    def main(self):
        token = open("token", "r")
        updater = telegram.Updater(token.read().rstrip('\n'))
        # Registrar los controladores de comandos
        dp = updater.dispatcher
        #Agregar comandos
        for comando, metodo in self.comandos.iteritems():
            dp.addTelegramCommandHandler(comando, metodo)
        # Si no se recibe un comando
        dp.addTelegramMessageHandler(self.echo)
        # Si sucede un error se pinta mensaje de error
        dp.addErrorHandler(self.error)
        # Iniciar el bot
        updater.start_polling(timeout=5)
        updater.idle()
    '''
    brief: Saludo al ususario
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def start(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_saludo)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def help(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_ayuda)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def echo(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def cd(self, bot, update):
        chat_id = update.message.chat_id
        mess_id = update.message.message_id
        reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(self.ruta_actual), one_time_keyboard = True, selective = True)
        bot.sendMessage(chat_id=chat_id, text="Seleciona el directorio al que quieres ir \
        o el archivo que quieres descargar",reply_to_message_id=mess_id, reply_markup=reply_markup)


    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def pwd(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def comando(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def sudo(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que retorna una lista de directorios y archivos de la ubicación ruta
    param: ruta: posición de que retornara

    '''
    def contenidoRuta(self, ruta):
        directorios = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type d", shell=True, stdout=subprocess.PIPE).stdout.read()
        archivos    = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type f", shell=True, stdout=subprocess.PIPE).stdout.read()
        lista_directorios = directorios.split('\n')
        #Ir hacia atrás
        lista_directorios.append('..')
        lista_archivos    = archivos.split('\n')
        lista = []
        lista.append(lista_directorios)
        lista.append(lista_archivos)
        #Para eliminar el ./ y la ruta antes de cada nombre de carpeta/archivo que retorna find. Así se limpia un poco la data
        for indice_lista in range(len(lista)):
            for dir, indice in zip(lista[indice_lista], range(len(lista[indice_lista]))):
                if ruta + '/' in lista[indice_lista][indice]:
                    lista[indice_lista][indice] = lista[indice_lista][indice].replace(ruta + '/', '')
            #.Archivos ocultos de último
            lista[indice_lista].sort()
            lista[indice_lista].reverse()
        return lista

    def crearListaOpcionesCd(self, ruta):
        markup_opc = []
        grupos = 3 #grupos de tres elementos (Funciona a partir de 3    )
        lista_data = [[telegram.Emoji.FILE_FOLDER + " Directorios " + telegram.Emoji.FILE_FOLDER], [telegram.Emoji.NEWSPAPER + " Archivos " + telegram.Emoji.NEWSPAPER]]
        lista_archivos_directorios = self.contenidoRuta(ruta)
        pos_lista_in = 0

        for indice in range(len(lista_data)):
            markup_opc.append(lista_data[indice])
            indice_individual = 0
            for indice_grupo in range( int(round(float(len(lista_archivos_directorios[indice])) / grupos))):
                markup_opc.append(list())
                #pos_lista_in += 1
                for indice_lis_dir in range(grupos):
                    if indice_individual <= len(lista_archivos_directorios[indice]):
                        markup_opc[len(markup_opc) - 1].append(lista_archivos_directorios[indice][indice_individual].decode('utf-8'))
                    indice_individual += 1


        return markup_opc



    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
           error:      error a mostrar
    '''
    def error(self, bot, update, error):
        logger.warn('Update "%s" caused error "%s"' % (update, error))

    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           respuesta:  respuesta a enviar
    '''
    def enviarMensaje(self, bot, update, respuesta):
        chat_id = update.message.chat_id
        nombre_usuario = update.message.from_user.first_name
        alias          = update.message.from_user.username
        print "Protobot dice a " + nombre_usuario.encode('utf-8') + " (" + alias.encode('utf-8') + "): " + respuesta
        reply_markup = telegram.ReplyKeyboardHide(hide_keyboard = True)
        bot.sendChatAction(chat_id=chat_id, action=telegram.ChatAction.TYPING)
        bot.sendMessage(chat_id=chat_id, text=respuesta, reply_markup=reply_markup)
robot = conbot()
