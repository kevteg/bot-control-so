#!/usr/bin/env python
# -*- coding: utf-8 -*-

import telegram
import logging
import sys
import subprocess

class conbot:
    def __init__ (self):
        root = logging.getLogger()
        root.setLevel(logging.INFO)
        ch = logging.StreamHandler(sys.stdout)
        ch.setLevel(logging.DEBUG)
        formatter = \
            logging.Formatter('\nActualización:\nHora: %(asctime)s \nObjeto: %(name)s \nTipo de dato: %(levelname)s \nMensaje: %(message)s')
        ch.setFormatter(formatter)
        root.addHandler(ch)
        self.logger = logging.getLogger(__name__)
        self.ruta_defecto = "/home/keeeevin"
        self.comandos = {'start': self.start,
                    'help': self.help,
                    'cd': self.cd,
                    'pwd': self.pwd,
                    'comando': self.comando,
                    'sudo': self.sudo}
        usuario = "@keeeevin"
        self.mensaje_saludo = "Hola. Soy un bot de control para la computadora de " + usuario + ".\nDe tener acceso podras navegar, \
                                descargar datos y ejecutar comandos en su computadora"
        self.mensaje_ayuda  = self.mensaje_saludo + "\n\nMis comandos son: \
                                                help - Ayuda del bot\
                                                cd - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                ls - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                pwd - Mostrar ruta actual\
                                                comando - Ejecutar un comando\
                                                sudo - Guardar contraseña de super usuario\
                                                "
        self.atras = telegram.Emoji.BACK_WITH_LEFTWARDS_ARROW_ABOVE + '(..)' + telegram.Emoji.BACK_WITH_LEFTWARDS_ARROW_ABOVE
        self.dir = telegram.Emoji.FILE_FOLDER + " Directorios " + telegram.Emoji.FILE_FOLDER
        self.arc = telegram.Emoji.NEWSPAPER + " Archivos " + telegram.Emoji.NEWSPAPER
        self.nombre_bot = "controlBot"
        self.main()

    '''
    brief: Método inicial que crea el handler de comandos
    '''
    def main(self):
        token = open("token", "r")
        updater = telegram.Updater(token.read().rstrip('\n'))
        # Registrar los controladores de comandos
        dp = updater.dispatcher
        #Agregar comandos
        for comando, metodo in self.comandos.iteritems():
            dp.addTelegramCommandHandler(comando, metodo)
        # Si no se recibe un comando
        dp.addTelegramMessageHandler(self.echo)
        # Si sucede un error se pinta mensaje de error
        dp.addErrorHandler(self.error)
        # Iniciar el bot
        updater.start_polling(timeout=5)
        updater.idle()
    '''
    brief: Saludo al ususario
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def start(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_saludo)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def help(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_ayuda)
    '''
    brief: Método que verifica que respuesta de un usuario este en opciones a escoger
    param: chat_id:     id del chat
           message:     mensaje que envia usuario
    return: -1 si no esta el mensaje o si usuario no ha usado cd
             0 si es directorio
             1 si es archivo
    '''
    def messageIsDirArc(self, chat_id, message):
        file = open("ruta_chats", "a+")
        if (message != self.dir and message != self.arc):
            if(str(chat_id) + "\n" in file):
                opciones_ruta = self.contenidoRuta(self.getPwd(chat_id))
                for indice in range(len(opciones_ruta)):
                    for objeto in opciones_ruta[indice]:
                        if message == objeto:
                            return indice
        return -1


    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def echo(self, bot, update):
        self.notiInfo(update)
        chat_id  = update.message.chat_id
        mess_id  = update.message.message_id
        document = update.message.document

        if document != None:
            ruta_actual = self.getPwd(chat_id)
            print "Documento: " + document.file_id
            bot.getFile(document.file_id).download(document.file_name)
            subprocess.Popen("mv " + document.file_name + " " + ruta_actual.decode('utf-8'), shell=True, stdout=subprocess.PIPE)
            self.enviarMensaje(bot, update, "Su archivo, " + document.file_name + ", ha sido puesto en " + ruta_actual.decode('utf-8'))
        else:
            message = update.message.text.encode('utf-8')
            if(self.messageIsDirArc(chat_id, message) == 0):
                if ' ' in message:
                    message = message.replace(' ', '\ ')

                if message != self.atras:
                    ruta_actual = self.getPwd(chat_id)
                    if ruta_actual == '/':
                        nueva_ruta = ruta_actual + message
                    else:
                        nueva_ruta = ruta_actual + '/' + message
                else:
                    directorios = (self.getPwd(chat_id)).split('/')
                    nueva_ruta = ''
                    #Verificar que no se esta al inicio del árbol
                    if len(directorios) > 2:
                        for indice in range(1, (len(directorios) - 1)):
                            nueva_ruta += '/' + directorios[indice]
                    else:
                        nueva_ruta = '/'
                self.chdir(chat_id, "ruta_chats", nueva_ruta)
                reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(nueva_ruta), one_time_keyboard = True, selective = True)
                self.enviarMensaje(bot, update, "Su nueva ruta es: " + nueva_ruta, reply_markup=reply_markup)
            elif(self.messageIsDirArc(chat_id, message) == 1):
                self.sendFile(bot, update, message)
            else:
                bot.sendMessage(update.message.chat_id, text=update.message.text)

    '''
    brief: Método que cambia o agrega el directorio del usuario chat_id
    param: chat_id:     chat_id a quien se cambiará la ruta
           file_name:    nombre archivo de los id
           ruta_del_id: ruta a asociar con el chat_id
    '''
    def chdir(self, chat_id, file_name, ruta_del_id):
        file = open(file_name, "a+")
        if(not(str(chat_id) + "\n" in file)):
            file.seek(2, 0)
            file.write(str(chat_id) + "\n")
            file.write(ruta_del_id + "\n")
            file.close()
        else:
            file.close()
            file = open(file_name, "r")
            info = file.readlines()
            file.close()
            file = open(file_name, "w")
            find = False
            for line in info:
                if line != str(chat_id) + "\n":
                    if not find:
                        file.write(line)
                    else:
                        file.write(ruta_del_id + '\n')
                        find = False
                else:
                    file.write(line)
                    find = True
            file.close()
    '''
    brief:  Método que obtiene la ruta del chat id actual
    param:  chat_id:        id del chat
    return: ruta de chat_id
    '''
    def getPwd(self, chat_id):
        file = open("ruta_chats", "r")
        info = file.readlines()
        find = False
        for line in info:
            if find:
                ruta = line
                find = False
            if line == str(chat_id) + "\n":
                find = True

        file.close()

        return ruta.replace('\n', '')

    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def cd(self, bot, update):
        self.notiInfo(update)
        chat_id        = update.message.chat_id
        ruta_chats = open("ruta_chats", "a+")
        if(not(str(chat_id) + "\n" in ruta_chats)):
            self.chdir(chat_id, "ruta_chats", self.ruta_defecto)
            ruta = self.ruta_defecto
        else:
            ruta = self.getPwd(chat_id)

        reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(ruta), one_time_keyboard = True, selective = True)
        self.enviarMensaje(bot, update, "Su ruta actual es: " + ruta.decode('utf-8') + "\nSeleciona el directorio al que quieres ir o el archivo que quieres descargar", reply_markup=reply_markup)
    '''
    brief: Método que envia archivo a usuario
    param: chat_id: id del chat a enviar archivo
           archivo: ruta del archivo a enviar
    '''
    def sendFile(self, bot, update,  nombre_archivo):
        chat_id  = update.message.chat_id
        ruta_usuario = self.getPwd(chat_id)
        ruta_archivo = ruta_usuario + '/' + nombre_archivo
        reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(ruta_usuario), one_time_keyboard = True, selective = True)
        self.enviarMensaje(bot, update, "Enviaré este archivo (El envio puede tardar): ".decode("utf-8") + nombre_archivo + ".\nSu ruta actual es: " + ruta_usuario.decode('utf-8'), reply_markup=reply_markup)
        bot.sendChatAction(chat_id=chat_id, action=telegram.ChatAction.UPLOAD_DOCUMENT)
        bot.sendDocument(chat_id=chat_id, document=open(ruta_archivo, 'r'))



    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def pwd(self, bot, update):
        self.notiInfo(update)
        chat_id = update.message.chat_id
        ruta_usuario = self.getPwd(chat_id)
        reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(ruta_usuario), one_time_keyboard = True, selective = True)
        self.enviarMensaje(bot, update, "Su ruta actual es " + ruta_usuario.decode("utf-8"), reply_markup=reply_markup)

    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def comando(self, bot, update):
        self.notiInfo(update)
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def sudo(self, bot, update, ):
        self.notiInfo(update)
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que retorna una lista de directorios y archivos de la ubicación ruta
    param: ruta: posición de que retornara

    '''
    def contenidoRuta(self, ruta):
        directorios = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type d", shell=True, stdout=subprocess.PIPE).stdout.read()
        archivos    = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type f", shell=True, stdout=subprocess.PIPE).stdout.read()
        lista_directorios = directorios.split('\n')
        #Ir hacia atrás
        lista_directorios.append(self.atras)
        lista_archivos    = archivos.split('\n')
        lista = []
        lista.append(lista_directorios)
        lista.append(lista_archivos)

        #print "RUTA: " + ruta
        if '\ ' in ruta:
            ruta = ruta.replace('\ ', ' ')

        #Para eliminar el ./ y la ruta antes de cada nombre de carpeta/archivo que retorna find. Así se limpia un poco la data
        for indice_lista in range(len(lista)):
            for dir, indice in zip(lista[indice_lista], range(len(lista[indice_lista]))):
                if ruta + '/' in dir:
                    lista[indice_lista][indice] = dir.replace(ruta + '/', '')
                elif ruta == '/':
                    lista[indice_lista][indice] = dir.replace(ruta, '')
            #.Archivos ocultos de último
            lista[indice_lista].sort()
            lista[indice_lista].reverse()
        return lista

    def crearListaOpcionesCd(self, ruta):
        markup_opc = []
        grupos = 3 #grupos de tres elementos (Funciona a partir de 3    )
        lista_data = [[self.dir], [self.arc]]
        lista_archivos_directorios = self.contenidoRuta(ruta)
        pos_lista_in = 0

        for indice in range(len(lista_data)):
            markup_opc.append(lista_data[indice])
            indice_individual = 0
            for indice_grupo in range( int(round(float(len(lista_archivos_directorios[indice])) / grupos))):
                markup_opc.append(list())
                for indice_lis_dir in range(grupos):
                    if indice_individual < len(lista_archivos_directorios[indice]):
                        markup_opc[len(markup_opc) - 1].append(lista_archivos_directorios[indice][indice_individual].decode('utf-8'))
                    indice_individual += 1


        return markup_opc



    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
           error:      error a mostrar
    '''
    def error(self, bot, update, error):
        self.logger.warn('Update "%s" caused error "%s"' % (update, error))
    '''
    brief: Método que muestra la información que envia un usuari
    param: update:     actualización que muestra el método
    '''
    def notiInfo(self, update):
        chat_id        = update.message.chat_id
        nombre_usuario = update.message.from_user.first_name
        alias          = update.message.from_user.username
        message        = update.message.text.encode('utf-8')
        print  "\n" + nombre_usuario.encode('utf-8') + " (" + alias.encode('utf-8') + "), dice: " + message
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           respuesta:  respuesta a enviar
    '''
    def enviarMensaje(self, bot, update, respuesta, reply_markup=None):
        chat_id        = update.message.chat_id
        mess_id        = update.message.message_id
        nombre_usuario = update.message.from_user.first_name
        alias          = update.message.from_user.username
        print self.nombre_bot + " dice a " + nombre_usuario.encode('utf-8') + " (" + alias.encode('utf-8') + "): " + respuesta
        if reply_markup is None:
            reply_markup = telegram.ReplyKeyboardHide(hide_keyboard = True)

        bot.sendChatAction(chat_id=chat_id, action=telegram.ChatAction.TYPING)
        bot.sendMessage(chat_id=chat_id, reply_to_message_id=mess_id, text=respuesta, reply_markup=reply_markup)
robot = conbot()
