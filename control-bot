#!/usr/bin/env python
# -*- coding: utf-8 -*-

import telegram
import logging
import sys
import subprocess

class conbot:
    def __init__ (self):
        root = logging.getLogger()
        root.setLevel(logging.INFO)
        ch = logging.StreamHandler(sys.stdout)
        ch.setLevel(logging.DEBUG)
        formatter = \
            logging.Formatter('Hora: %(asctime)s \
                               Objeto: %(name)s \
                               Tipo de dato: %(levelname)s \
                               Mensaje: %(message)s')
        ch.setFormatter(formatter)
        root.addHandler(ch)
        logger = logging.getLogger(__name__)
        self.ruta_defecto = "/home/keeeevin"
        self.comandos = {'start': self.start,
                    'help': self.help,
                    'cd': self.cd,
                    'pwd': self.pwd,
                    'comando': self.comando,
                    'sudo': self.sudo}
        usuario = "@keeeevin"
        self.mensaje_saludo = "Hola. Soy un bot de control para la computadora de " + usuario + ".\nDe tener acceso podras navegar, \
                                descargar datos y ejecutar comandos en su computadora"
        self.mensaje_ayuda  = self.mensaje_saludo + "\n\nMis comandos son: \
                                                help - Ayuda del bot\
                                                cd - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                ls - Mostrar carpetas y archivos para cambiar ubicacion actual       \
                                                pwd - Mostrar ruta actual\
                                                comando - Ejecutar un comando\
                                                sudo - Guardar contraseña de super usuario\
                                                "
        self.atras = telegram.Emoji.BACK_WITH_LEFTWARDS_ARROW_ABOVE + '(..)' + telegram.Emoji.BACK_WITH_LEFTWARDS_ARROW_ABOVE
        self.main()

    '''
    brief: Método inicial que crea el handler de comandos
    '''
    def main(self):
        token = open("token", "r")
        updater = telegram.Updater(token.read().rstrip('\n'))
        # Registrar los controladores de comandos
        dp = updater.dispatcher
        #Agregar comandos
        for comando, metodo in self.comandos.iteritems():
            dp.addTelegramCommandHandler(comando, metodo)
        # Si no se recibe un comando
        dp.addTelegramMessageHandler(self.echo)
        # Si sucede un error se pinta mensaje de error
        dp.addErrorHandler(self.error)
        # Iniciar el bot
        updater.start_polling(timeout=5)
        updater.idle()
    '''
    brief: Saludo al ususario
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def start(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_saludo)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def help(self, bot, update):
        self.enviarMensaje(bot, update, self.mensaje_ayuda)
    '''
    brief: Método que verifica que respuesta de un usuario este en opciones a escoger
    param: chat_id:     id del chat
           message:     mensaje que envia usuario
    return: -1 si no esta el mensaje o si usuario no ha usado cd
             0 si es directorio
             1 si es archivo
    '''
    def messageIsDirArc(self, chat_id, message):
        file = open("ruta_chats", "a+")
        if(str(chat_id) + "\n" in file):
            opciones_ruta = self.contenidoRuta(self.getPwd(chat_id))
            for indice in range(len(opciones_ruta)):
                for objeto in opciones_ruta[indice]:
                    if message == objeto:
                        return indice
        return -1


    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def echo(self, bot, update):
        chat_id = update.message.chat_id
        mess_id = update.message.message_id
        message = update.message.text.encode('utf-8')
        if(self.messageIsDirArc(chat_id, message) == 0):
            if ' ' in message:
                message = message.replace(' ', '\ ')

            if message != self.atras:
                nueva_ruta = self.getPwd(chat_id) + '/' + message
            else:
                directorios = (self.getPwd(chat_id)).split('/')
                nueva_ruta = ''
                for indice in range(1, (len(directorios) - 1)):
                    print directorios[indice]
                    nueva_ruta += '/' + directorios[indice]

            self.chdir(chat_id, "ruta_chats", nueva_ruta)
            reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(nueva_ruta), one_time_keyboard = True, selective = True)
            bot.sendMessage(chat_id=chat_id, text="Su nueva ruta es: " + nueva_ruta,reply_to_message_id=mess_id, reply_markup=reply_markup)
        elif(self.messageIsDirArc(chat_id, message) == 1):
            self.sendFile(chat_id, message)
        else:
            bot.sendMessage(update.message.chat_id, text=update.message.text)

    '''
    brief: Método que cambia o agrega el directorio del usuario chat_id
    param: chat_id:     chat_id a quien se cambiará la ruta
           file_name:    nombre archivo de los id
           ruta_del_id: ruta a asociar con el chat_id
    '''
    def chdir(self, chat_id, file_name, ruta_del_id):
        file = open(file_name, "a+")
        if(not(str(chat_id) + "\n" in file)):
            file.seek(2, 0)
            file.write(str(chat_id) + "\n")
            file.write(ruta_del_id + "\n")
            file.close()
        else:
            file.close()
            file = open(file_name, "r")
            info = file.readlines()
            file.close()
            file = open(file_name, "w")
            find = False
            for line in info:
                if line != str(chat_id) + "\n":
                    if not find:
                        file.write(line)
                    else:
                        file.write(ruta_del_id + '\n')
                        find = False
                else:
                    file.write(line)
                    find = True
            file.close()
    '''
    brief:  Método que obtiene la ruta del chat id actual
    param:  chat_id:        id del chat
    return: ruta de chat_id
    '''
    def getPwd(self, chat_id):
        file = open("ruta_chats", "r")
        info = file.readlines()
        find = False
        for line in info:
            if find:
                ruta = line
                find = False
            if line == str(chat_id) + "\n":
                find = True

        file.close()

        return ruta.replace('\n', '')

    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def cd(self, bot, update):
        ruta_chats = open("ruta_chats", "a+")
        chat_id = update.message.chat_id
        mess_id = update.message.message_id
        if(not(str(chat_id) + "\n" in ruta_chats)):
            self.chdir(chat_id, "ruta_chats", self.ruta_defecto)
            ruta = self.ruta_defecto
        else:
            ruta = self.getPwd(chat_id)

        reply_markup = telegram.ReplyKeyboardMarkup(self.crearListaOpcionesCd(ruta), one_time_keyboard = True, selective = True)
        bot.sendMessage(chat_id=chat_id, text="Su ruta actual es: " + ruta + "\nSeleciona el directorio al que quieres ir o el archivo que quieres descargar",reply_to_message_id=mess_id, reply_markup=reply_markup)
    '''
    brief: Método que envia archivo a usuario
    param: chat_id: id del chat a enviar archivo
           archivo: ruta del archivo a enviar
    '''
    def sendFile(self, chat_id, archivo):
        pass
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def pwd(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def comando(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
    '''
    def sudo(self, bot, update):
        bot.sendMessage(update.message.chat_id, text=update.message.text)
    '''
    brief: Método que retorna una lista de directorios y archivos de la ubicación ruta
    param: ruta: posición de que retornara

    '''
    def contenidoRuta(self, ruta):
        directorios = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type d", shell=True, stdout=subprocess.PIPE).stdout.read()
        archivos    = subprocess.Popen("find " + ruta + " -mindepth 1 -maxdepth 1 -type f", shell=True, stdout=subprocess.PIPE).stdout.read()
        lista_directorios = directorios.split('\n')
        #Ir hacia atrás
        lista_directorios.append(self.atras)
        lista_archivos    = archivos.split('\n')
        lista = []
        lista.append(lista_directorios)
        lista.append(lista_archivos)

        if '\ ' in ruta:
            ruta = ruta.replace('\ ', ' ')
        print ruta

        #Para eliminar el ./ y la ruta antes de cada nombre de carpeta/archivo que retorna find. Así se limpia un poco la data
        for indice_lista in range(len(lista)):
            for dir, indice in zip(lista[indice_lista], range(len(lista[indice_lista]))):
                if ruta + '/' in lista[indice_lista][indice]:
                    lista[indice_lista][indice] = lista[indice_lista][indice].replace(ruta + '/', '')
            #.Archivos ocultos de último
            lista[indice_lista].sort()
            lista[indice_lista].reverse()
        return lista

    def crearListaOpcionesCd(self, ruta):
        markup_opc = []
        grupos = 3 #grupos de tres elementos (Funciona a partir de 3    )
        lista_data = [[telegram.Emoji.FILE_FOLDER + " Directorios " + telegram.Emoji.FILE_FOLDER], [telegram.Emoji.NEWSPAPER + " Archivos " + telegram.Emoji.NEWSPAPER]]
        lista_archivos_directorios = self.contenidoRuta(ruta)
        pos_lista_in = 0

        for indice in range(len(lista_data)):
            markup_opc.append(lista_data[indice])
            indice_individual = 0
            for indice_grupo in range( int(round(float(len(lista_archivos_directorios[indice])) / grupos))):
                markup_opc.append(list())
                #pos_lista_in += 1
                for indice_lis_dir in range(grupos):
                    if indice_individual < len(lista_archivos_directorios[indice]):
                        markup_opc[len(markup_opc) - 1].append(lista_archivos_directorios[indice][indice_individual].decode('utf-8'))
                    indice_individual += 1


        return markup_opc



    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           bot:        bot que esta en funcionamiento
           error:      error a mostrar
    '''
    def error(self, bot, update, error):
        logger.warn('Update "%s" caused error "%s"' % (update, error))

    '''
    brief: Método que envia una respuesta al update
    param: update:     actualización que llamo el comando
           respuesta:  respuesta a enviar
    '''
    def enviarMensaje(self, bot, update, respuesta):
        chat_id = update.message.chat_id
        nombre_usuario = update.message.from_user.first_name
        alias          = update.message.from_user.username
        print "Protobot dice a " + nombre_usuario.encode('utf-8') + " (" + alias.encode('utf-8') + "): " + respuesta
        reply_markup = telegram.ReplyKeyboardHide(hide_keyboard = True)
        bot.sendChatAction(chat_id=chat_id, action=telegram.ChatAction.TYPING)
        bot.sendMessage(chat_id=chat_id, text=respuesta, reply_markup=reply_markup)
robot = conbot()
